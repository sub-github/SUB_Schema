<?xml version="1.0" encoding="UTF-8"?>
<!--
This file was generated by Altova MapForce 2014r2

YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.

Refer to the Altova MapForce Documentation for further details.
http://www.altova.com/mapforce
-->
<xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
    xmlns:tbf="http://www.altova.com/MapForce/UDF/tbf" 
    xmlns:ns0="http://www.loc.gov/mods/v3" 
    xmlns:xlink="http://www.w3.org/1999/xlink" 
    xmlns:xs="http://www.w3.org/2001/XMLSchema" 
    xmlns:fn="http://www.w3.org/2005/xpath-functions" 
    xmlns:xml="http://www.w3.org/XML/1998/namespace" 
    exclude-result-prefixes="tbf ns0 xs fn">
	<xsl:template name="tbf:tbf1_nameDefinition">
		<xsl:param name="input" select="()"/>
		<xsl:for-each select="$input/@ID">
			<xsl:attribute name="ID" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@authority">
			<xsl:attribute name="authority" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@authorityURI">
			<xsl:attribute name="authorityURI" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@valueURI">
			<xsl:attribute name="valueURI" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@xlink:type">
			<xsl:attribute name="xlink:type" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@xlink:href">
			<xsl:attribute name="xlink:href" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@xlink:role">
			<xsl:attribute name="xlink:role" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@xlink:arcrole">
			<xsl:attribute name="xlink:arcrole" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@xlink:title">
			<xsl:attribute name="xlink:title" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@xlink:show">
			<xsl:attribute name="xlink:show" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@xlink:actuate">
			<xsl:attribute name="xlink:actuate" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@lang">
			<xsl:attribute name="lang" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@xml:lang">
			<xsl:attribute name="xml:lang" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@script">
			<xsl:attribute name="script" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@transliteration">
			<xsl:attribute name="transliteration" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@displayLabel">
			<xsl:attribute name="displayLabel" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@altRepGroup">
			<xsl:attribute name="altRepGroup" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@nameTitleGroup">
			<xsl:attribute name="nameTitleGroup" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@usage">
			<xsl:attribute name="usage" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@type">
			<xsl:attribute name="type" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/node()">
			<xsl:choose>
				<xsl:when test="fn:boolean(self::*)">
					<xsl:if test="fn:boolean(self::ns0:namePart)">
						<xsl:element name="{node-name(.)}" namespace="{namespace-uri(.)}">
							<xsl:call-template name="tbf:tbf2_namePartDefinition">
								<xsl:with-param name="input" select="." as="node()"/>
							</xsl:call-template>
						</xsl:element>
					</xsl:if>
					<xsl:if test="fn:boolean(self::ns0:displayForm)">
						<xsl:variable name="var1_resultof_tbf__stringPlusLanguage" as="node()*">
							<xsl:call-template name="tbf:tbf3_stringPlusLanguage">
								<xsl:with-param name="input" select="." as="node()"/>
							</xsl:call-template>
						</xsl:variable>
						<xsl:variable name="var2_resultof_node_name" as="xs:QName" select="fn:node-name(.)"/>
						<xsl:element name="{node-name(.)}" namespace="{namespace-uri(.)}">
							<xsl:sequence select="$var1_resultof_tbf__stringPlusLanguage"/>
						</xsl:element>
					</xsl:if>
					<xsl:if test="fn:boolean(self::ns0:affiliation)">
						<xsl:variable name="var3_resultof_tbf__stringPlusLanguage" as="node()*">
							<xsl:call-template name="tbf:tbf3_stringPlusLanguage">
								<xsl:with-param name="input" select="." as="node()"/>
							</xsl:call-template>
						</xsl:variable>
						<xsl:variable name="var4_resultof_node_name" as="xs:QName" select="fn:node-name(.)"/>
						<xsl:element name="{node-name(.)}" namespace="{namespace-uri(.)}">
							<xsl:sequence select="$var3_resultof_tbf__stringPlusLanguage"/>
						</xsl:element>
					</xsl:if>
					<xsl:if test="fn:boolean(self::ns0:role)">
						<xsl:element name="{node-name(.)}" namespace="{namespace-uri(.)}">
							<xsl:call-template name="tbf:tbf4_roleDefinition">
								<xsl:with-param name="input" select="." as="node()"/>
							</xsl:call-template>
						</xsl:element>
					</xsl:if>
					<xsl:if test="fn:boolean(self::ns0:description)">
						<xsl:variable name="var5_resultof_tbf__stringPlusLanguage" as="node()*">
							<xsl:call-template name="tbf:tbf3_stringPlusLanguage">
								<xsl:with-param name="input" select="." as="node()"/>
							</xsl:call-template>
						</xsl:variable>
						<xsl:variable name="var6_resultof_node_name" as="xs:QName" select="fn:node-name(.)"/>
						<xsl:element name="{node-name(.)}" namespace="{namespace-uri(.)}">
							<xsl:sequence select="$var5_resultof_tbf__stringPlusLanguage"/>
						</xsl:element>
					</xsl:if>
					<xsl:if test="fn:boolean(self::ns0:etal)">
						<xsl:variable name="var7_resultof_tbf__stringPlusLanguage" as="node()*">
							<xsl:call-template name="tbf:tbf3_stringPlusLanguage">
								<xsl:with-param name="input" select="." as="node()"/>
							</xsl:call-template>
						</xsl:variable>
						<xsl:variable name="var8_resultof_node_name" as="xs:QName" select="fn:node-name(.)"/>
						<xsl:element name="{node-name(.)}" namespace="{namespace-uri(.)}">
							<xsl:sequence select="$var7_resultof_tbf__stringPlusLanguage"/>
						</xsl:element>
					</xsl:if>
				</xsl:when>
				<xsl:otherwise>
					<xsl:if test="fn:not(fn:boolean(self::text()))">
						<xsl:sequence select="."/>
					</xsl:if>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:for-each>
	</xsl:template>
	<xsl:template name="tbf:tbf2_namePartDefinition">
		<xsl:param name="input" select="()"/>
		<xsl:for-each select="$input/@lang">
			<xsl:attribute name="lang" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@xml:lang">
			<xsl:attribute name="xml:lang" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@script">
			<xsl:attribute name="script" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@transliteration">
			<xsl:attribute name="transliteration" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@type">
			<xsl:attribute name="type" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:sequence select="fn:string($input)"/>
	</xsl:template>
	<xsl:template name="tbf:tbf3_stringPlusLanguage">
		<xsl:param name="input" select="()"/>
		<xsl:for-each select="$input/@lang">
			<xsl:attribute name="lang" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@xml:lang">
			<xsl:attribute name="xml:lang" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@script">
			<xsl:attribute name="script" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@transliteration">
			<xsl:attribute name="transliteration" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:sequence select="fn:string($input)"/>
	</xsl:template>
	<xsl:template name="tbf:tbf4_roleDefinition">
		<xsl:param name="input" select="()"/>
		<xsl:for-each select="$input/node()">
			<xsl:choose>
				<xsl:when test="fn:boolean(self::*)">
					<xsl:if test="fn:boolean(self::ns0:roleTerm)">
						<xsl:element name="{node-name(.)}" namespace="{namespace-uri(.)}">
							<xsl:call-template name="tbf:tbf5_roleTermDefinition">
								<xsl:with-param name="input" select="." as="node()"/>
							</xsl:call-template>
						</xsl:element>
					</xsl:if>
				</xsl:when>
				<xsl:otherwise>
					<xsl:if test="fn:not(fn:boolean(self::text()))">
						<xsl:sequence select="."/>
					</xsl:if>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:for-each>
	</xsl:template>
	<xsl:template name="tbf:tbf5_roleTermDefinition">
		<xsl:param name="input" select="()"/>
		<xsl:for-each select="$input/@lang">
			<xsl:attribute name="lang" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@xml:lang">
			<xsl:attribute name="xml:lang" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@script">
			<xsl:attribute name="script" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@transliteration">
			<xsl:attribute name="transliteration" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@authority">
			<xsl:attribute name="authority" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@authorityURI">
			<xsl:attribute name="authorityURI" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@valueURI">
			<xsl:attribute name="valueURI" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:for-each select="$input/@type">
			<xsl:attribute name="type" select="fn:string(.)"/>
		</xsl:for-each>
		<xsl:sequence select="fn:string($input)"/>
	</xsl:template>
	<xsl:output method="xml" encoding="UTF-8" byte-order-mark="no" indent="yes"/>
	<xsl:template match="/">
		<xsl:variable name="var1_mods" as="node()?" select="ns0:mods"/>
		<xsl:variable name="var2_resultof_map" as="xs:boolean?">
			<xsl:for-each select="$var1_mods">
				<xsl:sequence select="fn:exists(ns0:titleInfo[fn:exists(ns0:nonSort)])"/>
			</xsl:for-each>
		</xsl:variable>
		<xsl:variable name="var3_resultof_any" as="xs:boolean" select="fn:exists($var1_mods[fn:exists(ns0:titleInfo[fn:exists(ns0:nonSort)])])"/>
		<xsl:variable name="var4_resultof_any" as="xs:boolean" select="fn:exists($var1_mods[fn:exists(ns0:titleInfo[fn:exists(ns0:subTitle)])])"/>
		<xsl:variable name="var5_resultof_map" as="node()*">
			<xsl:for-each select="($var1_mods/ns0:originInfo)[fn:exists(ns0:edition[(fn:string(.) = '[Electronic ed.]')])]">
				<originInfo xmlns="http://www.loc.gov/mods/v3" xmlns:xlink="http://www.w3.org/1999/xlink">
					<xsl:sequence select="@node()"/>
					<xsl:sequence select="node()"/>
				</originInfo>
			</xsl:for-each>
		</xsl:variable>
		<xsl:variable name="var6_resultof_map" as="node()*">
			<xsl:for-each select="($var1_mods/ns0:originInfo)[fn:exists(ns0:edition[(fn:string(.) != '[Electronic ed.]')])]">
				<originInfo xmlns="http://www.loc.gov/mods/v3" xmlns:xlink="http://www.w3.org/1999/xlink">
					<xsl:sequence select="@node()"/>
					<xsl:sequence select="node()"/>
				</originInfo>
			</xsl:for-each>
		</xsl:variable>
		<xsl:variable name="var7_resultof_map" as="xs:boolean?">
			<xsl:for-each select="$var1_mods">
				<xsl:sequence select="fn:exists(ns0:subject[fn:exists(ns0:titleInfo[fn:exists(ns0:nonSort)])])"/>
			</xsl:for-each>
		</xsl:variable>
		<xsl:variable name="var8_resultof_any" as="xs:boolean" select="fn:exists($var1_mods[fn:exists(ns0:subject[fn:exists(ns0:titleInfo[fn:exists(ns0:nonSort)])])])"/>
		<xsl:variable name="var9_resultof_any" as="xs:boolean" select="fn:exists($var1_mods[fn:exists(ns0:subject[fn:exists(ns0:titleInfo[fn:exists(ns0:subTitle)])])])"/>
		<xsl:variable name="var17_val" as="xs:string?">
			<xsl:choose>
				<xsl:when test="$var3_resultof_any">
					<xsl:variable name="var12_resultof_filter" as="node()*">
						<xsl:for-each select="$var1_mods">
							<xsl:variable name="var11_resultof_filter" as="node()*">
								<xsl:for-each select="ns0:titleInfo">
									<xsl:variable name="var10_current" as="node()" select="."/>
									<xsl:if test="fn:exists(ns0:nonSort[fn:exists($var10_current/ns0:title)])">
										<xsl:sequence select="."/>
									</xsl:if>
								</xsl:for-each>
							</xsl:variable>
							<xsl:if test="fn:exists($var11_resultof_filter)">
								<xsl:sequence select="."/>
							</xsl:if>
						</xsl:for-each>
					</xsl:variable>
					<xsl:if test="fn:exists($var12_resultof_filter)">
						<xsl:variable name="var15_resultof_map" as="xs:string*">
							<xsl:for-each select="$var1_mods/ns0:titleInfo">
								<xsl:variable name="var14_current" as="node()" select="."/>
								<xsl:for-each select="ns0:nonSort">
									<xsl:variable name="var13_current" as="node()" select="."/>
									<xsl:for-each select="$var14_current/ns0:title">
										<xsl:sequence select="fn:concat(fn:concat(fn:string($var13_current), ' '), fn:string(.))"/>
									</xsl:for-each>
								</xsl:for-each>
							</xsl:for-each>
						</xsl:variable>
						<xsl:sequence select="xs:string(fn:string-join(for $x in $var15_resultof_map return xs:string($x), ' '))"/>
					</xsl:if>
				</xsl:when>
				<xsl:otherwise>
					<xsl:if test="fn:exists($var1_mods[fn:exists(ns0:titleInfo[fn:exists(ns0:title)])])">
						<xsl:variable name="var16_resultof_map" as="xs:string*">
							<xsl:for-each select="$var1_mods/ns0:titleInfo/ns0:title">
								<xsl:sequence select="fn:string(.)"/>
							</xsl:for-each>
						</xsl:variable>
						<xsl:sequence select="xs:string(fn:string-join(for $x in $var16_resultof_map return xs:string($x), ' '))"/>
					</xsl:if>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:variable name="var18_resultof_exists" as="xs:boolean" select="fn:exists($var17_val)"/>
		<xsl:variable name="var27_val" as="xs:string?">
			<xsl:choose>
				<xsl:when test="$var8_resultof_any">
					<xsl:variable name="var22_resultof_filter" as="node()*">
						<xsl:for-each select="$var1_mods">
							<xsl:variable name="var21_resultof_filter" as="node()*">
								<xsl:for-each select="ns0:subject">
									<xsl:variable name="var20_resultof_filter" as="node()*">
										<xsl:for-each select="ns0:titleInfo">
											<xsl:variable name="var19_current" as="node()" select="."/>
											<xsl:if test="fn:exists(ns0:nonSort[fn:exists($var19_current/ns0:title)])">
												<xsl:sequence select="."/>
											</xsl:if>
										</xsl:for-each>
									</xsl:variable>
									<xsl:if test="fn:exists($var20_resultof_filter)">
										<xsl:sequence select="."/>
									</xsl:if>
								</xsl:for-each>
							</xsl:variable>
							<xsl:if test="fn:exists($var21_resultof_filter)">
								<xsl:sequence select="."/>
							</xsl:if>
						</xsl:for-each>
					</xsl:variable>
					<xsl:if test="fn:exists($var22_resultof_filter)">
						<xsl:variable name="var25_resultof_map" as="xs:string*">
							<xsl:for-each select="$var1_mods/ns0:subject/ns0:titleInfo">
								<xsl:variable name="var24_current" as="node()" select="."/>
								<xsl:for-each select="ns0:nonSort">
									<xsl:variable name="var23_current" as="node()" select="."/>
									<xsl:for-each select="$var24_current/ns0:title">
										<xsl:sequence select="fn:concat(fn:concat(fn:string($var23_current), ' '), fn:string(.))"/>
									</xsl:for-each>
								</xsl:for-each>
							</xsl:for-each>
						</xsl:variable>
						<xsl:sequence select="xs:string(fn:string-join(for $x in $var25_resultof_map return xs:string($x), ' '))"/>
					</xsl:if>
				</xsl:when>
				<xsl:otherwise>
					<xsl:if test="fn:exists($var1_mods[fn:exists(ns0:subject[fn:exists(ns0:titleInfo[fn:exists(ns0:title)])])])">
						<xsl:variable name="var26_resultof_map" as="xs:string*">
							<xsl:for-each select="$var1_mods/ns0:subject/ns0:titleInfo/ns0:title">
								<xsl:sequence select="fn:string(.)"/>
							</xsl:for-each>
						</xsl:variable>
						<xsl:sequence select="xs:string(fn:string-join(for $x in $var26_resultof_map return xs:string($x), ' '))"/>
					</xsl:if>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:variable name="var28_resultof_exists" as="xs:boolean" select="fn:exists($var27_val)"/>
		<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:dcr="http://www.isocat.org/ns/dcr">
			<xsl:attribute name="xsi:schemaLocation" namespace="http://www.w3.org/2001/XMLSchema-instance" select="'http://www.tei-c.org/ns/1.0 //psf/Home/Documents/projects/konzepte/Sub-Schema/my/tei_lite.xsd'"/>
			<teiHeader>
				<fileDesc>
					<xsl:for-each select="$var1_mods/ns0:physicalDescription/ns0:extent">
						<extent>
							<xsl:sequence select="fn:string(.)"/>
						</extent>
					</xsl:for-each>
					<publicationStmt>
						<xsl:variable name="var29_resultof_map" as="node()*" select="$var5_resultof_map"/>
						<xsl:for-each select="$var29_resultof_map/ns0:publisher">
							<publisher>
								<xsl:sequence select="fn:string(.)"/>
							</publisher>
						</xsl:for-each>
						<xsl:variable name="var30_resultof_map" as="node()*" select="$var5_resultof_map"/>
						<xsl:for-each select="$var30_resultof_map/ns0:dateCaptured">
							<date>
								<xsl:attribute name="type" namespace="" select="fn:node-name(.)"/>
								<xsl:sequence select="fn:string(.)"/>
							</date>
						</xsl:for-each>
						<xsl:variable name="var31_resultof_map" as="node()*" select="$var5_resultof_map"/>
						<xsl:for-each select="$var31_resultof_map/ns0:place/ns0:placeTerm">
							<pubPlace>
								<xsl:sequence select="fn:string(.)"/>
							</pubPlace>
						</xsl:for-each>
					</publicationStmt>
					<sourceDesc>
						<bibl>
							<xsl:variable name="var42_result" as="xs:string?">
								<xsl:choose>
									<xsl:when test="$var4_resultof_any">
										<xsl:if test="($var18_resultof_exists and fn:exists($var1_mods[fn:exists(ns0:titleInfo[fn:exists(ns0:subTitle)])]))">
											<xsl:variable name="var37_result" as="xs:string*">
												<xsl:if test="$var18_resultof_exists">
													<xsl:for-each select="$var1_mods/ns0:titleInfo/ns0:subTitle">
														<xsl:variable name="var36_result" as="xs:string">
															<xsl:choose>
																<xsl:when test="$var3_resultof_any">
																	<xsl:variable name="var34_resultof_map" as="xs:string*">
																		<xsl:for-each select="$var1_mods/ns0:titleInfo">
																			<xsl:variable name="var33_current" as="node()" select="."/>
																			<xsl:for-each select="ns0:nonSort">
																				<xsl:variable name="var32_current" as="node()" select="."/>
																				<xsl:for-each select="$var33_current/ns0:title">
																					<xsl:sequence select="fn:concat(fn:concat(fn:string($var32_current), ' '), fn:string(.))"/>
																				</xsl:for-each>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:sequence select="xs:string(fn:string-join(for $x in $var34_resultof_map return xs:string($x), ' '))"/>
																</xsl:when>
																<xsl:otherwise>
																	<xsl:variable name="var35_resultof_map" as="xs:string*">
																		<xsl:for-each select="$var1_mods/ns0:titleInfo/ns0:title">
																			<xsl:sequence select="fn:string(.)"/>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:sequence select="xs:string(fn:string-join(for $x in $var35_resultof_map return xs:string($x), ' '))"/>
																</xsl:otherwise>
															</xsl:choose>
														</xsl:variable>
														<xsl:sequence select="fn:concat(fn:concat($var36_result, ' : '), fn:string(.))"/>
													</xsl:for-each>
												</xsl:if>
											</xsl:variable>
											<xsl:sequence select="xs:string(fn:string-join(for $x in $var37_result return xs:string($x), ' '))"/>
										</xsl:if>
									</xsl:when>
									<xsl:otherwise>
										<xsl:if test="$var18_resultof_exists">
											<xsl:choose>
												<xsl:when test="$var3_resultof_any">
													<xsl:variable name="var40_resultof_map" as="xs:string*">
														<xsl:for-each select="$var1_mods/ns0:titleInfo">
															<xsl:variable name="var39_current" as="node()" select="."/>
															<xsl:for-each select="ns0:nonSort">
																<xsl:variable name="var38_current" as="node()" select="."/>
																<xsl:for-each select="$var39_current/ns0:title">
																	<xsl:sequence select="fn:concat(fn:concat(fn:string($var38_current), ' '), fn:string(.))"/>
																</xsl:for-each>
															</xsl:for-each>
														</xsl:for-each>
													</xsl:variable>
													<xsl:sequence select="xs:string(fn:string-join(for $x in $var40_resultof_map return xs:string($x), ' '))"/>
												</xsl:when>
												<xsl:otherwise>
													<xsl:variable name="var41_resultof_map" as="xs:string*">
														<xsl:for-each select="$var1_mods/ns0:titleInfo/ns0:title">
															<xsl:sequence select="fn:string(.)"/>
														</xsl:for-each>
													</xsl:variable>
													<xsl:sequence select="xs:string(fn:string-join(for $x in $var41_resultof_map return xs:string($x), ' '))"/>
												</xsl:otherwise>
											</xsl:choose>
										</xsl:if>
									</xsl:otherwise>
								</xsl:choose>
							</xsl:variable>
							<xsl:if test="fn:exists($var42_result)">
								<title>
									<xsl:choose>
										<xsl:when test="$var4_resultof_any">
											<xsl:variable name="var48_result" as="xs:string*">
												<xsl:if test="$var18_resultof_exists">
													<xsl:for-each select="$var1_mods/ns0:titleInfo/ns0:subTitle">
														<xsl:variable name="var47_result" as="xs:string">
															<xsl:choose>
																<xsl:when test="$var3_resultof_any">
																	<xsl:variable name="var45_resultof_map" as="xs:string*">
																		<xsl:for-each select="$var1_mods/ns0:titleInfo">
																			<xsl:variable name="var44_current" as="node()" select="."/>
																			<xsl:for-each select="ns0:nonSort">
																				<xsl:variable name="var43_current" as="node()" select="."/>
																				<xsl:for-each select="$var44_current/ns0:title">
																					<xsl:sequence select="fn:concat(fn:concat(fn:string($var43_current), ' '), fn:string(.))"/>
																				</xsl:for-each>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:sequence select="xs:string(fn:string-join(for $x in $var45_resultof_map return xs:string($x), ' '))"/>
																</xsl:when>
																<xsl:otherwise>
																	<xsl:variable name="var46_resultof_map" as="xs:string*">
																		<xsl:for-each select="$var1_mods/ns0:titleInfo/ns0:title">
																			<xsl:sequence select="fn:string(.)"/>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:sequence select="xs:string(fn:string-join(for $x in $var46_resultof_map return xs:string($x), ' '))"/>
																</xsl:otherwise>
															</xsl:choose>
														</xsl:variable>
														<xsl:sequence select="fn:concat(fn:concat($var47_result, ' : '), fn:string(.))"/>
													</xsl:for-each>
												</xsl:if>
											</xsl:variable>
											<xsl:sequence select="xs:string(fn:string-join(for $x in $var48_result return xs:string($x), ' '))"/>
										</xsl:when>
										<xsl:when test="$var3_resultof_any">
											<xsl:variable name="var51_resultof_map" as="xs:string*">
												<xsl:for-each select="$var1_mods/ns0:titleInfo">
													<xsl:variable name="var50_current" as="node()" select="."/>
													<xsl:for-each select="ns0:nonSort">
														<xsl:variable name="var49_current" as="node()" select="."/>
														<xsl:for-each select="$var50_current/ns0:title">
															<xsl:sequence select="fn:concat(fn:concat(fn:string($var49_current), ' '), fn:string(.))"/>
														</xsl:for-each>
													</xsl:for-each>
												</xsl:for-each>
											</xsl:variable>
											<xsl:sequence select="xs:string(fn:string-join(for $x in $var51_resultof_map return xs:string($x), ' '))"/>
										</xsl:when>
										<xsl:otherwise>
											<xsl:variable name="var52_resultof_map" as="xs:string*">
												<xsl:for-each select="$var1_mods/ns0:titleInfo/ns0:title">
													<xsl:sequence select="fn:string(.)"/>
												</xsl:for-each>
											</xsl:variable>
											<xsl:sequence select="xs:string(fn:string-join(for $x in $var52_resultof_map return xs:string($x), ' '))"/>
										</xsl:otherwise>
									</xsl:choose>
								</title>
							</xsl:if>
							<xsl:variable name="var53_resultof_map" as="node()*" select="$var6_resultof_map"/>
							<xsl:for-each select="$var53_resultof_map/ns0:dateIssued">
								<date>
									<xsl:attribute name="type" namespace="" select="fn:node-name(.)"/>
									<xsl:sequence select="fn:string(.)"/>
								</date>
							</xsl:for-each>
							<xsl:variable name="var54_resultof_map" as="node()*" select="$var6_resultof_map"/>
							<xsl:for-each select="$var54_resultof_map/ns0:dateCreated">
								<date>
									<xsl:attribute name="type" namespace="" select="fn:node-name(.)"/>
									<xsl:sequence select="fn:string(.)"/>
								</date>
							</xsl:for-each>
							<xsl:variable name="var55_resultof_map" as="node()*" select="$var6_resultof_map"/>
							<xsl:for-each select="$var55_resultof_map/ns0:dateOther">
								<date>
									<xsl:if test="fn:exists(@type)">
										<xsl:attribute name="type" namespace="" select="fn:string(@type)"/>
									</xsl:if>
									<xsl:sequence select="fn:string(.)"/>
								</date>
							</xsl:for-each>
							<xsl:variable name="var60_resultof_map" as="node()*">
								<xsl:for-each select="($var1_mods/ns0:name)[fn:exists(ns0:role[fn:exists(ns0:roleTerm[(fn:string(.) = 'aut')])])]">
									<name xmlns="http://www.loc.gov/mods/v3" xmlns:xlink="http://www.w3.org/1999/xlink">
										<xsl:sequence select="@node()"/>
										<xsl:sequence select="node()"/>
									</name>
								</xsl:for-each>
							</xsl:variable>
							<xsl:variable name="var61_let" as="node()*">
								<xsl:for-each select="(($var60_resultof_map/ns0:namePart)[fn:exists(@type)])[(fn:string(@type) = 'family')]">
									<namePart xmlns="http://www.loc.gov/mods/v3" xmlns:xlink="http://www.w3.org/1999/xlink">
										<xsl:sequence select="@node()"/>
										<xsl:sequence select="node()"/>
									</namePart>
								</xsl:for-each>
							</xsl:variable>
							<author>
								<xsl:for-each select="$var61_let">
									<xsl:variable name="var59_current" as="node()" select="."/>
									<xsl:variable name="var58_index" as="xs:integer" select="position()"/>
									<xsl:variable name="var56_resultof_map" as="node()*">
										<xsl:for-each select="($var1_mods/ns0:name)[fn:exists(ns0:role[fn:exists(ns0:roleTerm[(fn:string(.) = 'aut')])])]">
											<name xmlns="http://www.loc.gov/mods/v3" xmlns:xlink="http://www.w3.org/1999/xlink">
												<xsl:sequence select="@node()"/>
												<xsl:sequence select="node()"/>
											</name>
										</xsl:for-each>
									</xsl:variable>
									<xsl:variable name="var57_let" as="node()*">
										<xsl:for-each select="(($var56_resultof_map/ns0:namePart)[fn:exists(@type)])[(fn:string(@type) = 'given')]">
											<namePart xmlns="http://www.loc.gov/mods/v3" xmlns:xlink="http://www.w3.org/1999/xlink">
												<xsl:sequence select="@node()"/>
												<xsl:sequence select="node()"/>
											</namePart>
										</xsl:for-each>
									</xsl:variable>
									<xsl:for-each select="$var57_let">
										<xsl:if test="($var58_index = position())">
											<name>
												<xsl:sequence select="fn:concat(fn:concat(fn:string($var59_current), ', '), fn:string(.))"/>
											</name>
										</xsl:if>
									</xsl:for-each>
								</xsl:for-each>
							</author>
							<xsl:variable name="var66_resultof_map" as="node()*">
								<xsl:for-each select="($var1_mods/ns0:name)[fn:exists(ns0:role[fn:exists(ns0:roleTerm[(fn:string(.) = 'edt')])])]">
									<name xmlns="http://www.loc.gov/mods/v3" xmlns:xlink="http://www.w3.org/1999/xlink">
										<xsl:sequence select="@node()"/>
										<xsl:sequence select="node()"/>
									</name>
								</xsl:for-each>
							</xsl:variable>
							<xsl:variable name="var67_let" as="node()*">
								<xsl:for-each select="(($var66_resultof_map/ns0:namePart)[fn:exists(@type)])[(fn:string(@type) = 'family')]">
									<namePart xmlns="http://www.loc.gov/mods/v3" xmlns:xlink="http://www.w3.org/1999/xlink">
										<xsl:sequence select="@node()"/>
										<xsl:sequence select="node()"/>
									</namePart>
								</xsl:for-each>
							</xsl:variable>
							<editor>
								<xsl:for-each select="$var67_let">
									<xsl:variable name="var65_current" as="node()" select="."/>
									<xsl:variable name="var64_index" as="xs:integer" select="position()"/>
									<xsl:variable name="var62_resultof_map" as="node()*">
										<xsl:for-each select="($var1_mods/ns0:name)[fn:exists(ns0:role[fn:exists(ns0:roleTerm[(fn:string(.) = 'edt')])])]">
											<name xmlns="http://www.loc.gov/mods/v3" xmlns:xlink="http://www.w3.org/1999/xlink">
												<xsl:sequence select="@node()"/>
												<xsl:sequence select="node()"/>
											</name>
										</xsl:for-each>
									</xsl:variable>
									<xsl:variable name="var63_let" as="node()*">
										<xsl:for-each select="(($var62_resultof_map/ns0:namePart)[fn:exists(@type)])[(fn:string(@type) = 'given')]">
											<namePart xmlns="http://www.loc.gov/mods/v3" xmlns:xlink="http://www.w3.org/1999/xlink">
												<xsl:sequence select="@node()"/>
												<xsl:sequence select="node()"/>
											</namePart>
										</xsl:for-each>
									</xsl:variable>
									<xsl:for-each select="$var63_let">
										<xsl:if test="($var64_index = position())">
											<name>
												<xsl:sequence select="fn:concat(fn:concat(fn:string($var65_current), ', '), fn:string(.))"/>
											</name>
										</xsl:if>
									</xsl:for-each>
								</xsl:for-each>
							</editor>
							<xsl:variable name="var68_resultof_map" as="node()*" select="$var6_resultof_map"/>
							<xsl:for-each select="$var68_resultof_map/ns0:publisher">
								<publisher>
									<xsl:sequence select="fn:string(.)"/>
								</publisher>
							</xsl:for-each>
							<xsl:variable name="var69_resultof_map" as="node()*" select="$var6_resultof_map"/>
							<xsl:for-each select="$var69_resultof_map/ns0:place/ns0:placeTerm">
								<pubPlace>
									<xsl:sequence select="fn:string(.)"/>
								</pubPlace>
							</xsl:for-each>
						</bibl>
					</sourceDesc>
				</fileDesc>
				<profileDesc>
					<langUsage>
						<xsl:for-each select="$var1_mods/ns0:language/ns0:languageTerm">
							<language>
								<xsl:sequence select="fn:string(.)"/>
							</language>
						</xsl:for-each>
					</langUsage>
					<textClass>
						<xsl:for-each select="$var1_mods/ns0:classification">
							<classCode>
								<xsl:sequence select="fn:string(.)"/>
							</classCode>
						</xsl:for-each>
						<keywords>
							<xsl:for-each select="$var1_mods/ns0:genre">
								<term>
									<xsl:attribute name="type" namespace="" select="xs:string(fn:node-name(.))"/>
									<xsl:sequence select="fn:string(.)"/>
								</term>
							</xsl:for-each>
							<list>
								<xsl:for-each select="$var1_mods/ns0:subject/ns0:topic">
									<item>
										<xsl:sequence select="fn:string(.)"/>
									</item>
								</xsl:for-each>
								<xsl:for-each select="$var1_mods/ns0:subject/ns0:geographic">
									<item>
										<xsl:sequence select="fn:string(.)"/>
									</item>
								</xsl:for-each>
								<xsl:for-each select="$var1_mods/ns0:subject/ns0:temporal">
									<item>
										<xsl:sequence select="fn:string(.)"/>
									</item>
								</xsl:for-each>
								<xsl:variable name="var80_result" as="xs:string?">
									<xsl:choose>
										<xsl:when test="$var9_resultof_any">
											<xsl:if test="($var28_resultof_exists and fn:exists($var1_mods[fn:exists(ns0:subject[fn:exists(ns0:titleInfo[fn:exists(ns0:subTitle)])])]))">
												<xsl:variable name="var75_result" as="xs:string*">
													<xsl:if test="$var28_resultof_exists">
														<xsl:for-each select="$var1_mods/ns0:subject/ns0:titleInfo/ns0:subTitle">
															<xsl:variable name="var74_result" as="xs:string">
																<xsl:choose>
																	<xsl:when test="$var8_resultof_any">
																		<xsl:variable name="var72_resultof_map" as="xs:string*">
																			<xsl:for-each select="$var1_mods/ns0:subject/ns0:titleInfo">
																				<xsl:variable name="var71_current" as="node()" select="."/>
																				<xsl:for-each select="ns0:nonSort">
																					<xsl:variable name="var70_current" as="node()" select="."/>
																					<xsl:for-each select="$var71_current/ns0:title">
																						<xsl:sequence select="fn:concat(fn:concat(fn:string($var70_current), ' '), fn:string(.))"/>
																					</xsl:for-each>
																				</xsl:for-each>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:sequence select="xs:string(fn:string-join(for $x in $var72_resultof_map return xs:string($x), ' '))"/>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:variable name="var73_resultof_map" as="xs:string*">
																			<xsl:for-each select="$var1_mods/ns0:subject/ns0:titleInfo/ns0:title">
																				<xsl:sequence select="fn:string(.)"/>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:sequence select="xs:string(fn:string-join(for $x in $var73_resultof_map return xs:string($x), ' '))"/>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:variable>
															<xsl:sequence select="fn:concat(fn:concat($var74_result, ' : '), fn:string(.))"/>
														</xsl:for-each>
													</xsl:if>
												</xsl:variable>
												<xsl:sequence select="xs:string(fn:string-join(for $x in $var75_result return xs:string($x), ' '))"/>
											</xsl:if>
										</xsl:when>
										<xsl:otherwise>
											<xsl:if test="$var28_resultof_exists">
												<xsl:choose>
													<xsl:when test="$var8_resultof_any">
														<xsl:variable name="var78_resultof_map" as="xs:string*">
															<xsl:for-each select="$var1_mods/ns0:subject/ns0:titleInfo">
																<xsl:variable name="var77_current" as="node()" select="."/>
																<xsl:for-each select="ns0:nonSort">
																	<xsl:variable name="var76_current" as="node()" select="."/>
																	<xsl:for-each select="$var77_current/ns0:title">
																		<xsl:sequence select="fn:concat(fn:concat(fn:string($var76_current), ' '), fn:string(.))"/>
																	</xsl:for-each>
																</xsl:for-each>
															</xsl:for-each>
														</xsl:variable>
														<xsl:sequence select="xs:string(fn:string-join(for $x in $var78_resultof_map return xs:string($x), ' '))"/>
													</xsl:when>
													<xsl:otherwise>
														<xsl:variable name="var79_resultof_map" as="xs:string*">
															<xsl:for-each select="$var1_mods/ns0:subject/ns0:titleInfo/ns0:title">
																<xsl:sequence select="fn:string(.)"/>
															</xsl:for-each>
														</xsl:variable>
														<xsl:sequence select="xs:string(fn:string-join(for $x in $var79_resultof_map return xs:string($x), ' '))"/>
													</xsl:otherwise>
												</xsl:choose>
											</xsl:if>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:variable>
								<xsl:if test="fn:exists($var80_result)">
									<item>
										<xsl:choose>
											<xsl:when test="$var9_resultof_any">
												<xsl:variable name="var86_result" as="xs:string*">
													<xsl:if test="$var28_resultof_exists">
														<xsl:for-each select="$var1_mods/ns0:subject/ns0:titleInfo/ns0:subTitle">
															<xsl:variable name="var85_result" as="xs:string">
																<xsl:choose>
																	<xsl:when test="$var8_resultof_any">
																		<xsl:variable name="var83_resultof_map" as="xs:string*">
																			<xsl:for-each select="$var1_mods/ns0:subject/ns0:titleInfo">
																				<xsl:variable name="var82_current" as="node()" select="."/>
																				<xsl:for-each select="ns0:nonSort">
																					<xsl:variable name="var81_current" as="node()" select="."/>
																					<xsl:for-each select="$var82_current/ns0:title">
																						<xsl:sequence select="fn:concat(fn:concat(fn:string($var81_current), ' '), fn:string(.))"/>
																					</xsl:for-each>
																				</xsl:for-each>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:sequence select="xs:string(fn:string-join(for $x in $var83_resultof_map return xs:string($x), ' '))"/>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:variable name="var84_resultof_map" as="xs:string*">
																			<xsl:for-each select="$var1_mods/ns0:subject/ns0:titleInfo/ns0:title">
																				<xsl:sequence select="fn:string(.)"/>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:sequence select="xs:string(fn:string-join(for $x in $var84_resultof_map return xs:string($x), ' '))"/>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:variable>
															<xsl:sequence select="fn:concat(fn:concat($var85_result, ' : '), fn:string(.))"/>
														</xsl:for-each>
													</xsl:if>
												</xsl:variable>
												<xsl:sequence select="xs:string(fn:string-join(for $x in $var86_result return xs:string($x), ' '))"/>
											</xsl:when>
											<xsl:when test="$var8_resultof_any">
												<xsl:variable name="var89_resultof_map" as="xs:string*">
													<xsl:for-each select="$var1_mods/ns0:subject/ns0:titleInfo">
														<xsl:variable name="var88_current" as="node()" select="."/>
														<xsl:for-each select="ns0:nonSort">
															<xsl:variable name="var87_current" as="node()" select="."/>
															<xsl:for-each select="$var88_current/ns0:title">
																<xsl:sequence select="fn:concat(fn:concat(fn:string($var87_current), ' '), fn:string(.))"/>
															</xsl:for-each>
														</xsl:for-each>
													</xsl:for-each>
												</xsl:variable>
												<xsl:sequence select="xs:string(fn:string-join(for $x in $var89_resultof_map return xs:string($x), ' '))"/>
											</xsl:when>
											<xsl:otherwise>
												<xsl:variable name="var90_resultof_map" as="xs:string*">
													<xsl:for-each select="$var1_mods/ns0:subject/ns0:titleInfo/ns0:title">
														<xsl:sequence select="fn:string(.)"/>
													</xsl:for-each>
												</xsl:variable>
												<xsl:sequence select="xs:string(fn:string-join(for $x in $var90_resultof_map return xs:string($x), ' '))"/>
											</xsl:otherwise>
										</xsl:choose>
									</item>
								</xsl:if>
								<xsl:variable name="var95_resultof_map" as="node()*">
									<xsl:for-each select="($var1_mods/ns0:subject/ns0:name)[fn:exists(ns0:role[fn:exists(ns0:roleTerm[(fn:string(.) = 'aut')])])]">
										<name xmlns="http://www.loc.gov/mods/v3" xmlns:xlink="http://www.w3.org/1999/xlink">
											<xsl:call-template name="tbf:tbf1_nameDefinition">
												<xsl:with-param name="input" select="." as="node()"/>
											</xsl:call-template>
										</name>
									</xsl:for-each>
								</xsl:variable>
								<xsl:variable name="var96_let" as="node()*">
									<xsl:for-each select="(($var95_resultof_map/ns0:namePart)[fn:exists(@type)])[(fn:string(@type) = 'family')]">
										<namePart xmlns="http://www.loc.gov/mods/v3" xmlns:xlink="http://www.w3.org/1999/xlink">
											<xsl:sequence select="@node()"/>
											<xsl:sequence select="node()"/>
										</namePart>
									</xsl:for-each>
								</xsl:variable>
								<xsl:for-each select="$var96_let">
									<xsl:variable name="var94_current" as="node()" select="."/>
									<xsl:variable name="var93_index" as="xs:integer" select="position()"/>
									<xsl:variable name="var91_resultof_map" as="node()*">
										<xsl:for-each select="($var1_mods/ns0:subject/ns0:name)[fn:exists(ns0:role[fn:exists(ns0:roleTerm[(fn:string(.) = 'aut')])])]">
											<name xmlns="http://www.loc.gov/mods/v3" xmlns:xlink="http://www.w3.org/1999/xlink">
												<xsl:call-template name="tbf:tbf1_nameDefinition">
													<xsl:with-param name="input" select="." as="node()"/>
												</xsl:call-template>
											</name>
										</xsl:for-each>
									</xsl:variable>
									<xsl:variable name="var92_let" as="node()*">
										<xsl:for-each select="(($var91_resultof_map/ns0:namePart)[fn:exists(@type)])[(fn:string(@type) = 'given')]">
											<namePart xmlns="http://www.loc.gov/mods/v3" xmlns:xlink="http://www.w3.org/1999/xlink">
												<xsl:sequence select="@node()"/>
												<xsl:sequence select="node()"/>
											</namePart>
										</xsl:for-each>
									</xsl:variable>
									<xsl:for-each select="$var92_let">
										<xsl:if test="($var93_index = position())">
											<item>
												<xsl:sequence select="fn:concat(fn:concat(fn:string($var94_current), ', '), fn:string(.))"/>
											</item>
										</xsl:if>
									</xsl:for-each>
								</xsl:for-each>
								<xsl:variable name="var101_resultof_map" as="node()*">
									<xsl:for-each select="($var1_mods/ns0:subject/ns0:name)[fn:exists(ns0:role[fn:exists(ns0:roleTerm[(fn:string(.) = 'edt')])])]">
										<name xmlns="http://www.loc.gov/mods/v3" xmlns:xlink="http://www.w3.org/1999/xlink">
											<xsl:call-template name="tbf:tbf1_nameDefinition">
												<xsl:with-param name="input" select="." as="node()"/>
											</xsl:call-template>
										</name>
									</xsl:for-each>
								</xsl:variable>
								<xsl:variable name="var102_let" as="node()*">
									<xsl:for-each select="(($var101_resultof_map/ns0:namePart)[fn:exists(@type)])[(fn:string(@type) = 'family')]">
										<namePart xmlns="http://www.loc.gov/mods/v3" xmlns:xlink="http://www.w3.org/1999/xlink">
											<xsl:sequence select="@node()"/>
											<xsl:sequence select="node()"/>
										</namePart>
									</xsl:for-each>
								</xsl:variable>
								<xsl:for-each select="$var102_let">
									<xsl:variable name="var100_current" as="node()" select="."/>
									<xsl:variable name="var99_index" as="xs:integer" select="position()"/>
									<xsl:variable name="var97_resultof_map" as="node()*">
										<xsl:for-each select="($var1_mods/ns0:subject/ns0:name)[fn:exists(ns0:role[fn:exists(ns0:roleTerm[(fn:string(.) = 'edt')])])]">
											<name xmlns="http://www.loc.gov/mods/v3" xmlns:xlink="http://www.w3.org/1999/xlink">
												<xsl:call-template name="tbf:tbf1_nameDefinition">
													<xsl:with-param name="input" select="." as="node()"/>
												</xsl:call-template>
											</name>
										</xsl:for-each>
									</xsl:variable>
									<xsl:variable name="var98_let" as="node()*">
										<xsl:for-each select="(($var97_resultof_map/ns0:namePart)[fn:exists(@type)])[(fn:string(@type) = 'given')]">
											<namePart xmlns="http://www.loc.gov/mods/v3" xmlns:xlink="http://www.w3.org/1999/xlink">
												<xsl:sequence select="@node()"/>
												<xsl:sequence select="node()"/>
											</namePart>
										</xsl:for-each>
									</xsl:variable>
									<xsl:for-each select="$var98_let">
										<xsl:if test="($var99_index = position())">
											<item>
												<xsl:sequence select="fn:concat(fn:concat(fn:string($var100_current), ', '), fn:string(.))"/>
											</item>
										</xsl:if>
									</xsl:for-each>
								</xsl:for-each>
							</list>
						</keywords>
					</textClass>
				</profileDesc>
			</teiHeader>
		</TEI>
	</xsl:template>
</xsl:stylesheet>
